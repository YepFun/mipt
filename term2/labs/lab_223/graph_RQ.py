import matplotlib.pyplot as plt
import numpy as np
from scipy import stats

# Данные
data = {
    23.0: [
        (19.4857, 1.9615), (19.5115, 6.9520), (19.8278, 63.1519), (20.1286, 116.3273),
        (19.5507, 13.8999), (19.5914, 22.0863), (19.6482, 31.0361), (19.7072, 40.4285),
        (19.7452, 49.2171), (19.9212, 78.3586), (20.2672, 142.9475)
    ],
    30.0: [
        (19.9780, 2.0062), (19.9989, 7.0918), (20.0467, 14.1501), (20.0844, 22.4442),
        (20.1350, 31.4921), (20.1869, 40.9495), (20.2405, 49.8109), (20.2964, 60.1924),
        (20.3444, 69.6999), (20.4930, 96.8897), (20.7431, 143.3514)
    ],
    40.3: [
        (20.6957, 2.0688), (20.7642, 14.4810), (20.8109, 22.8987), (20.8617, 32.0398),
        (20.9137, 41.5586), (20.9620, 50.4625), (21.0188, 60.7363), (21.1335, 82.1353),
        (21.2139, 97.2319), (21.3174, 116.8394), (21.4554, 142.9338)
    ],
    50.0: [
        (21.3861, 2.1304), (21.4283, 10.2217), (21.4979, 23.3888), (21.5461, 32.6580),
        (21.5962, 42.2706), (21.6429, 51.2437), (21.6962, 61.6357), (21.8075, 82.9913),
        (21.9211, 105.2296), (22.1155, 143.3789), (22.2540, 170.5357)
    ],
    60.0: [
        (22.0994, 2.1935), (22.1401, 10.4855), (22.2083, 23.8760), (22.2636, 34.6363),
        (22.3057, 42.9703), (22.3648, 54.7025), (22.4025, 62.4384), (22.4523, 71.9612),
        (22.5134, 83.8069), (22.5861, 98.8101), (22.8089, 143.7439)
    ],
    70.1: [
        (22.8524, 10.7364), (22.9203, 24.3463), (22.9737, 35.2295), (23.0403, 49.0034),
        (23.1106, 63.1843), (23.2157, 84.5463), (23.2883, 99.4960), (23.3798, 118.7015),
        (23.5025, 143.9901), (23.6314, 170.3683)
    ],
    80.0: [
        (23.5246, 2.3179), (23.5731, 10.9867), (23.6357, 24.8095), (23.6894, 35.8099),
        (23.7531, 49.6742), (23.8210, 63.9043), (23.9193, 85.2288), (23.9916, 100.1134),
        (24.0827, 119.1860), (24.2010, 144.2003), (24.3548, 177.7600)
    ]
}

plt.figure(figsize=(8, 6))
cmap = plt.cm.rainbow
n = len(data)

for i, (temp, points) in enumerate(sorted(data.items())):
    R, Q = zip(*points)
    R = np.array(R)
    Q = np.array(Q)
    n_points = len(Q)

    # Линейная аппроксимация
    slope, intercept, r_value, p_value, std_err_slope = stats.linregress(Q, R)

    # Вычисляем std_err_intercept вручную
    Q_mean = np.mean(Q)
    SSx = np.sum((Q - Q_mean)**2)
    residuals = R - (slope * Q + intercept)
    s = np.sqrt(np.sum(residuals**2) / (n_points - 2))
    std_err_intercept = s * np.sqrt(1/n_points + Q_mean**2 / SSx)

    # Строим график
    Q_fit = np.linspace(min(Q), max(Q), 100)
    R_fit = slope * Q_fit + intercept
    color = cmap(i / (n - 1))

    plt.plot(Q, R, 'o', color=color, label=f'{temp}°C')
    plt.plot(Q_fit, R_fit, '-', color=color,
             label=f'R={slope:.4f}Q + {intercept:.2f}\nΔa={std_err_slope:.6f}, Δb={std_err_intercept:.6f}')

    # Выводим в консоль
    print(f"Температура {temp}°C:")
    print(f"  Уравнение: R = {slope:.6f} * Q + {intercept:.6f}")
    print(f"  Погрешность углового коэффициента Δa = {std_err_slope:.6f}")
    print(f"  Погрешность свободного коэффициента Δb = {std_err_intercept:.6f}\n")

plt.xlabel('Q, мВт')
plt.ylabel('R, Ом')
plt.title('Зависимость R(Q)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.savefig("images/graph_RQ.png")

